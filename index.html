<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Paisaje 3D simple — Three.js</title>
  <style>
    html,body{height:100%;margin:0}
    #app{width:100%;height:100%;display:block;overflow:hidden}
    #ui{position:fixed;left:10px;top:10px;z-index:10;background:rgba(255,255,255,0.85);padding:8px;border-radius:6px;font-family:system-ui,Arial}
    button{margin-right:6px}
  </style>
</head>
<body>
  <div id="ui">
    <strong>Paisaje 3D</strong>
    <div style="margin-top:6px">
      <button id="btn-reset">Reset cámara</button>
      <button id="btn-wire">Alternar wireframe</button>
      <button id="btn-screenshot">Screenshot</button>
    </div>
    <small style="display:block;margin-top:6px;color:#444">Si esto se ve en blanco, el problema es de WebGL / Pages.</small>
  </div>

  <div id="app"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    const container = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // cielo

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 30);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Luz
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    hemi.position.set(0, 50, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(-10, 20, 10);
    dir.castShadow = true;
    dir.shadow.camera.left = -30;
    dir.shadow.camera.right = 30;
    dir.shadow.camera.top = 30;
    dir.shadow.camera.bottom = -30;
    scene.add(dir);

    // Suelo plano (lejano)
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x557733 });
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.1;
    ground.receiveShadow = true;
    scene.add(ground);

    // Generar una malla tipo "paisaje" (plane con desplazamiento)
    const seg = 160;
    const geometry = new THREE.PlaneGeometry(60, 60, seg, seg);
    geometry.rotateX(-Math.PI/2);

    // Función de ruido simple (no es Perlin, pero da forma de paisaje)
    function noise(x, z){
      // combinación de senos para "montañas" suaves
      return (Math.sin(x*0.3) * 1.5 + Math.cos(z*0.25)*1.2 + Math.sin((x+z)*0.15)*2.5) * Math.exp(-(x*x+z*z)/1200);
    }

    const pos = geometry.attributes.position;
    for (let i=0; i<pos.count; i++){
      const x = pos.getX(i);
      const y = pos.getY(i);
      const z = pos.getZ(i);
      const h = noise(x, z) + (Math.random()-0.5)*0.2; // un poco de aleatorio
      pos.setY(i, h);
    }
    geometry.computeVertexNormals();

    const material = new THREE.MeshStandardMaterial({ color: 0x6ea04f, flatShading: false, metalness: 0.1, roughness: 0.8 });
    const terrain = new THREE.Mesh(geometry, material);
    terrain.receiveShadow = true;
    terrain.castShadow = true;
    scene.add(terrain);

    // Agregar unas "rocas" como ejemplo (esferas)
    for (let i=0; i<20; i++){
      const s = 0.5 + Math.random()*1.8;
      const m = new THREE.Mesh(new THREE.IcosahedronGeometry(s, 1), new THREE.MeshStandardMaterial({ color:0x8d7a6f }));
      const rx = (Math.random()*140 - 70) * 0.4;
      const rz = (Math.random()*140 - 70) * 0.4;
      // elevar sobre la malla: encontrar altura aproximada usando noise
      m.position.set(rx, noise(rx, rz) + 0.6, rz);
      m.castShadow = true;
      scene.add(m);
    }

    // Agua / niebla en distancia
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.004);

    // Controles
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,1,0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 5;
    controls.maxDistance = 120;
    controls.maxPolarAngle = Math.PI*0.48;

    // Resize
    window.addEventListener('resize', ()=> {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // UI botones
    document.getElementById('btn-reset').addEventListener('click', ()=> {
      camera.position.set(0,12,30);
      controls.target.set(0,1,0);
    });
    let wire = false;
    document.getElementById('btn-wire').addEventListener('click', ()=> {
      wire = !wire;
      material.wireframe = wire;
    });
    document.getElementById('btn-screenshot').addEventListener('click', ()=> {
      const data = renderer.domElement.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = data;
      a.download = 'paisaje.png';
      a.click();
    });

    // Render loop
    function animate(){
      requestAnimationFrame(animate);
      // ligera oscilación para más vida
      terrain.rotation.y += 0.0003;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Mensaje de debug en consola para confirmar WebGL
    if (!renderer.capabilities.isWebGL2) console.log('WebGL2 no disponible, usando WebGL1. Aun así debería funcionar.');
    console.log('Three.js listo — paisaje generado procedimentalmente.');
  </script>
</body>
</html>





